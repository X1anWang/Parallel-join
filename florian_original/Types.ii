# 1 "Enclave/Edger8rSyntax/Types.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "Enclave/Edger8rSyntax/Types.cpp"
# 35 "Enclave/Edger8rSyntax/Types.cpp"
# 1 "/opt/intel/new-sgxsdk/include/sgx_trts.h" 1
# 35 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
# 1 "/opt/intel/new-sgxsdk/include/sgx_error.h" 1
# 37 "/opt/intel/new-sgxsdk/include/sgx_error.h"
typedef enum _status_t
{
    SGX_SUCCESS = (0x00000000|(0x0000)),

    SGX_ERROR_UNEXPECTED = (0x00000000|(0x0001)),
    SGX_ERROR_INVALID_PARAMETER = (0x00000000|(0x0002)),
    SGX_ERROR_OUT_OF_MEMORY = (0x00000000|(0x0003)),
    SGX_ERROR_ENCLAVE_LOST = (0x00000000|(0x0004)),
    SGX_ERROR_INVALID_STATE = (0x00000000|(0x0005)),
    SGX_ERROR_FEATURE_NOT_SUPPORTED = (0x00000000|(0x0008)),
    SGX_PTHREAD_EXIT = (0x00000000|(0x0009)),
    SGX_ERROR_MEMORY_MAP_FAILURE = (0x00000000|(0x000a)),

    SGX_ERROR_INVALID_FUNCTION = (0x00000000|(0x1001)),
    SGX_ERROR_OUT_OF_TCS = (0x00000000|(0x1003)),
    SGX_ERROR_ENCLAVE_CRASHED = (0x00000000|(0x1006)),
    SGX_ERROR_ECALL_NOT_ALLOWED = (0x00000000|(0x1007)),
    SGX_ERROR_OCALL_NOT_ALLOWED = (0x00000000|(0x1008)),
    SGX_ERROR_STACK_OVERRUN = (0x00000000|(0x1009)),

    SGX_ERROR_UNDEFINED_SYMBOL = (0x00000000|(0x2000)),
    SGX_ERROR_INVALID_ENCLAVE = (0x00000000|(0x2001)),
    SGX_ERROR_INVALID_ENCLAVE_ID = (0x00000000|(0x2002)),
    SGX_ERROR_INVALID_SIGNATURE = (0x00000000|(0x2003)),
    SGX_ERROR_NDEBUG_ENCLAVE = (0x00000000|(0x2004)),
    SGX_ERROR_OUT_OF_EPC = (0x00000000|(0x2005)),
    SGX_ERROR_NO_DEVICE = (0x00000000|(0x2006)),
    SGX_ERROR_MEMORY_MAP_CONFLICT= (0x00000000|(0x2007)),
    SGX_ERROR_INVALID_METADATA = (0x00000000|(0x2009)),
    SGX_ERROR_DEVICE_BUSY = (0x00000000|(0x200c)),
    SGX_ERROR_INVALID_VERSION = (0x00000000|(0x200d)),
    SGX_ERROR_MODE_INCOMPATIBLE = (0x00000000|(0x200e)),
    SGX_ERROR_ENCLAVE_FILE_ACCESS = (0x00000000|(0x200f)),
    SGX_ERROR_INVALID_MISC = (0x00000000|(0x2010)),
    SGX_ERROR_INVALID_LAUNCH_TOKEN = (0x00000000|(0x2011)),

    SGX_ERROR_MAC_MISMATCH = (0x00000000|(0x3001)),
    SGX_ERROR_INVALID_ATTRIBUTE = (0x00000000|(0x3002)),
    SGX_ERROR_INVALID_CPUSVN = (0x00000000|(0x3003)),
    SGX_ERROR_INVALID_ISVSVN = (0x00000000|(0x3004)),
    SGX_ERROR_INVALID_KEYNAME = (0x00000000|(0x3005)),

    SGX_ERROR_SERVICE_UNAVAILABLE = (0x00000000|(0x4001)),
    SGX_ERROR_SERVICE_TIMEOUT = (0x00000000|(0x4002)),
    SGX_ERROR_AE_INVALID_EPIDBLOB = (0x00000000|(0x4003)),
    SGX_ERROR_SERVICE_INVALID_PRIVILEGE = (0x00000000|(0x4004)),
    SGX_ERROR_EPID_MEMBER_REVOKED = (0x00000000|(0x4005)),
    SGX_ERROR_UPDATE_NEEDED = (0x00000000|(0x4006)),
    SGX_ERROR_NETWORK_FAILURE = (0x00000000|(0x4007)),
    SGX_ERROR_AE_SESSION_INVALID = (0x00000000|(0x4008)),
    SGX_ERROR_BUSY = (0x00000000|(0x400a)),
    SGX_ERROR_MC_NOT_FOUND = (0x00000000|(0x400c)),
    SGX_ERROR_MC_NO_ACCESS_RIGHT = (0x00000000|(0x400d)),
    SGX_ERROR_MC_USED_UP = (0x00000000|(0x400e)),
    SGX_ERROR_MC_OVER_QUOTA = (0x00000000|(0x400f)),
    SGX_ERROR_KDF_MISMATCH = (0x00000000|(0x4011)),
    SGX_ERROR_UNRECOGNIZED_PLATFORM = (0x00000000|(0x4012)),
    SGX_ERROR_UNSUPPORTED_CONFIG = (0x00000000|(0x4013)),

    SGX_ERROR_NO_PRIVILEGE = (0x00000000|(0x5002)),


    SGX_ERROR_PCL_ENCRYPTED = (0x00000000|(0x6001)),
    SGX_ERROR_PCL_NOT_ENCRYPTED = (0x00000000|(0x6002)),
    SGX_ERROR_PCL_MAC_MISMATCH = (0x00000000|(0x6003)),
    SGX_ERROR_PCL_SHA_MISMATCH = (0x00000000|(0x6004)),
    SGX_ERROR_PCL_GUID_MISMATCH = (0x00000000|(0x6005)),


    SGX_ERROR_FILE_BAD_STATUS = (0x00000000|(0x7001)),
    SGX_ERROR_FILE_NO_KEY_ID = (0x00000000|(0x7002)),
    SGX_ERROR_FILE_NAME_MISMATCH = (0x00000000|(0x7003)),
    SGX_ERROR_FILE_NOT_SGX_FILE = (0x00000000|(0x7004)),
    SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE = (0x00000000|(0x7005)),
    SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE = (0x00000000|(0x7006)),
    SGX_ERROR_FILE_RECOVERY_NEEDED = (0x00000000|(0x7007)),
    SGX_ERROR_FILE_FLUSH_FAILED = (0x00000000|(0x7008)),
    SGX_ERROR_FILE_CLOSE_FAILED = (0x00000000|(0x7009)),


    SGX_ERROR_UNSUPPORTED_ATT_KEY_ID = (0x00000000|(0x8001)),
    SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE = (0x00000000|(0x8002)),
    SGX_ERROR_ATT_KEY_UNINITIALIZED = (0x00000000|(0x8003)),
    SGX_ERROR_INVALID_ATT_KEY_CERT_DATA = (0x00000000|(0x8004)),
    SGX_ERROR_PLATFORM_CERT_UNAVAILABLE = (0x00000000|(0x8005)),

    SGX_INTERNAL_ERROR_ENCLAVE_CREATE_INTERRUPTED = (0x00000000|(0xF001)),

} sgx_status_t;
# 36 "/opt/intel/new-sgxsdk/include/sgx_trts.h" 2
# 1 "/opt/intel/new-sgxsdk/include/tlibc/stddef.h" 1
# 38 "/opt/intel/new-sgxsdk/include/tlibc/stddef.h"
# 1 "/opt/intel/new-sgxsdk/include/tlibc/sys/cdefs.h" 1
# 39 "/opt/intel/new-sgxsdk/include/tlibc/stddef.h" 2
# 1 "/opt/intel/new-sgxsdk/include/tlibc/sys/_types.h" 1
# 39 "/opt/intel/new-sgxsdk/include/tlibc/sys/_types.h"
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long __int64_t;
typedef unsigned long __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;


typedef __int8_t __int_fast8_t;
typedef __uint8_t __uint_fast8_t;


typedef long int __int_fast16_t;
typedef unsigned long int __uint_fast16_t;
typedef long int __int_fast32_t;
typedef unsigned long int __uint_fast32_t;
typedef long int __int_fast64_t;
typedef unsigned long int __uint_fast64_t;
# 84 "/opt/intel/new-sgxsdk/include/tlibc/sys/_types.h"
typedef long __off_t;
# 97 "/opt/intel/new-sgxsdk/include/tlibc/sys/_types.h"
typedef __int64_t __intptr_t;
typedef __uint64_t __uintptr_t;
typedef __int64_t __ptrdiff_t;


typedef unsigned long __size_t;
typedef long __ssize_t;
typedef double __double_t;
typedef float __float_t;



typedef long __clock_t;

typedef long __time_t;
typedef __builtin_va_list __va_list;
typedef unsigned int __wint_t;

typedef unsigned long int __wctype_t;
typedef int * __wctrans_t;






typedef struct {
    int __c;
    union {
        __wint_t __wc;
        char __wcb[4];
    } __v;
} __mbstate_t;


typedef __int64_t __intmax_t;
typedef __uint64_t __uintmax_t;
# 40 "/opt/intel/new-sgxsdk/include/tlibc/stddef.h" 2



typedef __ptrdiff_t ptrdiff_t;




typedef __size_t size_t;
# 37 "/opt/intel/new-sgxsdk/include/sgx_trts.h" 2
# 1 "/opt/intel/new-sgxsdk/include/sgx_defs.h" 1
# 38 "/opt/intel/new-sgxsdk/include/sgx_trts.h" 2
# 1 "/opt/intel/new-sgxsdk/include/tlibc/stdint.h" 1
# 22 "/opt/intel/new-sgxsdk/include/tlibc/stdint.h"
# 1 "/opt/intel/new-sgxsdk/include/tlibc/sys/stdint.h" 1
# 28 "/opt/intel/new-sgxsdk/include/tlibc/sys/stdint.h"
typedef __int8_t int8_t;




typedef __uint8_t uint8_t;




typedef __int16_t int16_t;




typedef __uint16_t uint16_t;




typedef __int32_t int32_t;




typedef __uint32_t uint32_t;




typedef __int64_t int64_t;




typedef __uint64_t uint64_t;



typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;


typedef __int_fast8_t int_fast8_t;
typedef __uint_fast8_t uint_fast8_t;
typedef __int_fast16_t int_fast16_t;
typedef __uint_fast16_t uint_fast16_t;
typedef __int_fast32_t int_fast32_t;
typedef __uint_fast32_t uint_fast32_t;
typedef __int_fast64_t int_fast64_t;
typedef __uint_fast64_t uint_fast64_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;



typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 23 "/opt/intel/new-sgxsdk/include/tlibc/stdint.h" 2
# 39 "/opt/intel/new-sgxsdk/include/sgx_trts.h" 2


extern "C" {
# 53 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
int sgx_is_within_enclave(const void *addr, size_t size);
# 64 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
int sgx_is_outside_enclave(const void *addr, size_t size);







int sgx_is_enclave_crashed(void) __attribute__((section(".nipx")));
# 84 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
sgx_status_t sgx_read_rand(unsigned char *rand, size_t length_in_bytes);
# 93 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
int sgx_rdpkru(uint32_t *val);
# 102 "/opt/intel/new-sgxsdk/include/sgx_trts.h"
int sgx_wrpkru(uint32_t val);


}
# 36 "Enclave/Edger8rSyntax/Types.cpp" 2
# 1 "Enclave/Edger8rSyntax/../Enclave.h" 1
# 36 "Enclave/Edger8rSyntax/../Enclave.h"
# 1 "/opt/intel/new-sgxsdk/include/tlibc/stdlib.h" 1
# 55 "/opt/intel/new-sgxsdk/include/tlibc/stdlib.h"
typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long quot;
    long rem;
} ldiv_t;

typedef struct {
    long long quot;
    long long rem;
} lldiv_t;
# 86 "/opt/intel/new-sgxsdk/include/tlibc/stdlib.h"
extern "C" {

__attribute__ ((__noreturn__)) void abort(void);
int atexit(void (*)(void));
int abs(int);
double atof(const char *);
int atoi(const char *);
long atol(const char *);
void * bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
void * calloc(size_t, size_t);
div_t div(int, int);
void free(void *);
long labs(long);
ldiv_t ldiv(long, long);
void * malloc(size_t);
void * memalign(size_t, size_t);
void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
void * realloc(void *, size_t);
double strtod(const char *, char **);
long strtol(const char *, char **, int);
float strtof(const char *, char **);

long long
        atoll(const char *);
long long
        llabs(long long);
lldiv_t
        lldiv(long long, long long);
long long
        strtoll(const char *, char **, int);
unsigned long
        strtoul(const char *, char **, int);
long double
        strtold(const char *, char **);
unsigned long long
        strtoull(const char *, char **, int);

int mblen(const char *, size_t);
size_t mbstowcs(wchar_t *, const char *, size_t);
int wctomb(char *, wchar_t);
int mbtowc(wchar_t *, const char *, size_t);
size_t wcstombs(char *, const wchar_t *, size_t);





;
;
;
;
;
;




void * alloca(size_t);






}
# 37 "Enclave/Edger8rSyntax/../Enclave.h" 2
# 1 "/opt/intel/new-sgxsdk/include/tlibc/assert.h" 1
# 57 "/opt/intel/new-sgxsdk/include/tlibc/assert.h"
extern "C" {

void __assert(const char *, int, const char *, const char *);

}
# 38 "Enclave/Edger8rSyntax/../Enclave.h" 2


extern "C" {


void printf(const char *fmt, ...);
void process_input(char *buf, size_t len);


}
# 37 "Enclave/Edger8rSyntax/Types.cpp" 2
# 1 "Enclave/Enclave_t.h" 1




# 1 "/opt/intel/new-sgxsdk/include/tlibc/wchar.h" 1
# 84 "/opt/intel/new-sgxsdk/include/tlibc/wchar.h"
typedef __mbstate_t mbstate_t;




typedef __wint_t wint_t;
# 101 "/opt/intel/new-sgxsdk/include/tlibc/wchar.h"
extern "C" {

wint_t btowc(int);
int wctob(wint_t);
size_t mbrlen(const char *, size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
size_t wcrtomb(char *, wchar_t, mbstate_t *);
wchar_t * wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcslen(const wchar_t *);
wchar_t * wcsncat(wchar_t *, const wchar_t *, size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t * wcsncpy(wchar_t *, const wchar_t *, size_t);
wchar_t * wcspbrk(const wchar_t *, const wchar_t *);
wchar_t * wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t * wcsstr(const wchar_t *, const wchar_t *);
wchar_t * wcstok(wchar_t *, const wchar_t *, wchar_t **);
size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
wchar_t * wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t * wmemcpy(wchar_t *, const wchar_t *, size_t);
wchar_t * wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t * wmemset(wchar_t *, wchar_t, size_t);

int swprintf(wchar_t *, size_t, const wchar_t *, ...);
int vswprintf(wchar_t *, size_t, const wchar_t *, __va_list);

long double wcstold (const wchar_t *, wchar_t **);
long long wcstoll (const wchar_t *, wchar_t **, int);
unsigned long long wcstoull (const wchar_t *, wchar_t **, int);


wchar_t * wcswcs(const wchar_t *, const wchar_t *);

}
# 6 "Enclave/Enclave_t.h" 2

# 1 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h" 1
# 48 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h"
# 1 "/opt/intel/new-sgxsdk/include/sgx_eid.h" 1
# 37 "/opt/intel/new-sgxsdk/include/sgx_eid.h"
typedef uint64_t sgx_enclave_id_t;
# 49 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h" 2
# 59 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h"
extern "C" {
# 69 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h"
void* sgx_ocalloc(size_t size);







void sgx_ocfree(void);
# 88 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h"
sgx_status_t sgx_ecall(const sgx_enclave_id_t eid,
                              const int index,
                              const void* ocall_table,
                              void* ms);
sgx_status_t sgx_ecall_switchless(const sgx_enclave_id_t eid,
                              const int index,
                              const void* ocall_table,
                              void* ms);
# 104 "/opt/intel/new-sgxsdk/include/sgx_edger8r.h"
sgx_status_t sgx_ocall(const unsigned int index,
                              void* ms);
sgx_status_t sgx_ocall_switchless(const unsigned int index,
                              void* ms);


}
# 8 "Enclave/Enclave_t.h" 2

# 1 "IncludeL3/user_types.h" 1
# 38 "IncludeL3/user_types.h"
typedef void *buffer_t;
typedef int array_t[10];
# 10 "Enclave/Enclave_t.h" 2






extern "C" {




typedef struct struct_foo_t {
 uint32_t struct_foo_0;
 uint64_t struct_foo_1;
} struct_foo_t;


typedef enum enum_foo_t {
 ENUM_FOO_0 = 0,
 ENUM_FOO_1 = 1,
} enum_foo_t;



typedef union union_foo_t {
 uint32_t union_foo_0;
 uint32_t union_foo_1;
 uint64_t union_foo_3;
} union_foo_t;


void process_input(char* buf, size_t len);
void ecall_type_char(char val);
void ecall_type_int(int val);
void ecall_type_float(float val);
void ecall_type_double(double val);
void ecall_type_size_t(size_t val);
void ecall_type_wchar_t(wchar_t val);
void ecall_type_struct(struct struct_foo_t val);
void ecall_type_enum_union(enum enum_foo_t val1, union union_foo_t* val2);
size_t ecall_pointer_user_check(void* val, size_t sz);
void ecall_pointer_in(int* val);
void ecall_pointer_out(int* val);
void ecall_pointer_in_out(int* val);
void ecall_pointer_string(char* str);
void ecall_pointer_string_const(const char* str);
void ecall_pointer_size(void* ptr, size_t len);
void ecall_pointer_count(int* arr, int cnt);
void ecall_pointer_isptr_readonly(buffer_t buf, size_t len);
void ocall_pointer_attr(void);
void ecall_array_user_check(int arr[4]);
void ecall_array_in(int arr[4]);
void ecall_array_out(int arr[4]);
void ecall_array_in_out(int arr[4]);
void ecall_array_isary(array_t arr);
void ecall_function_calling_convs(void);
void ecall_function_public(void);
int ecall_function_private(void);
void ecall_malloc_free(void);
void ecall_sgx_cpuid(int cpuinfo[4], int leaf);
void ecall_exception(void);
void ecall_map(void);
size_t ecall_increase_counter(void);
void ecall_producer(void);
void ecall_consumer(void);

sgx_status_t ocall_print_string(const char* str);
sgx_status_t init_time(void);
sgx_status_t get_time(int if_print);
sgx_status_t ocall_pointer_user_check(int* val);
sgx_status_t ocall_pointer_in(int* val);
sgx_status_t ocall_pointer_out(int* val);
sgx_status_t ocall_pointer_in_out(int* val);
sgx_status_t memccpy(void** retval, void* dest, const void* src, int val, size_t len);
sgx_status_t ocall_function_allow(void);
sgx_status_t sgx_oc_cpuidex(int cpuinfo[4], int leaf, int subleaf);
sgx_status_t sgx_thread_wait_untrusted_event_ocall(int* retval, const void* self);
sgx_status_t sgx_thread_set_untrusted_event_ocall(int* retval, const void* waiter);
sgx_status_t sgx_thread_setwait_untrusted_events_ocall(int* retval, const void* waiter, const void* self);
sgx_status_t sgx_thread_set_multiple_untrusted_events_ocall(int* retval, const void** waiters, size_t total);


}
# 38 "Enclave/Edger8rSyntax/Types.cpp" 2
# 1 "/opt/intel/new-sgxsdk/include/libcxx/limits" 1
# 106 "/opt/intel/new-sgxsdk/include/libcxx/limits"
       
# 107 "/opt/intel/new-sgxsdk/include/libcxx/limits" 3


# 1 "/opt/intel/new-sgxsdk/include/libcxx/__config" 1 3
# 19 "/opt/intel/new-sgxsdk/include/libcxx/__config" 3
       
# 20 "/opt/intel/new-sgxsdk/include/libcxx/__config" 3
# 463 "/opt/intel/new-sgxsdk/include/libcxx/__config" 3
# 1 "/opt/intel/new-sgxsdk/include/libcxx/__sgx" 1 3
# 61 "/opt/intel/new-sgxsdk/include/libcxx/__sgx" 3
# 1 "/opt/intel/new-sgxsdk/include/tlibc/sys/endian.h" 1 3
# 62 "/opt/intel/new-sgxsdk/include/libcxx/__sgx" 2 3
# 77 "/opt/intel/new-sgxsdk/include/libcxx/__sgx" 3
# 1 "/opt/intel/new-sgxsdk/include/tlibc/assert.h" 1 3
# 78 "/opt/intel/new-sgxsdk/include/libcxx/__sgx" 2 3
# 464 "/opt/intel/new-sgxsdk/include/libcxx/__config" 2 3
# 553 "/opt/intel/new-sgxsdk/include/libcxx/__config" 3

# 553 "/opt/intel/new-sgxsdk/include/libcxx/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 110 "/opt/intel/new-sgxsdk/include/libcxx/limits" 2 3
# 1 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 1 3
# 387 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
# 1 "/opt/intel/new-sgxsdk/include/libcxx/cstddef" 1 3
# 41 "/opt/intel/new-sgxsdk/include/libcxx/cstddef" 3
       
# 42 "/opt/intel/new-sgxsdk/include/libcxx/cstddef" 3


namespace std { inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;





typedef long double max_align_t;
# 91 "/opt/intel/new-sgxsdk/include/libcxx/cstddef" 3
} }



namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 388 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 2 3


       
# 391 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3


namespace std { inline namespace __1 {

template <class _T1, class _T2> struct __attribute__ ((__visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__visibility__("default"))) hash;

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__ ((__visibility__("default"))) __dependent_type : public _Tp {};

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp> struct __attribute__ ((__visibility__("default"))) __lazy_enable_if {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};

template <bool, class _Tp = void> struct __attribute__ ((__visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};
# 441 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 491 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__visibility__("default"))) integral_constant
{
    static constexpr const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        constexpr operator value_type() const noexcept {return value;}




};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
# 520 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
typedef integral_constant<bool,(true)> true_type;
typedef integral_constant<bool,(false)> false_type;





template <bool _Last, class ..._Preds>
struct __lazy_and_impl;

template <class ..._Preds>
struct __lazy_and_impl<false, _Preds...> : false_type {};

template <>
struct __lazy_and_impl<true> : true_type {};

template <class _Pred>
struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};

template <class _Hp, class ..._Tp>
struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};



template <bool _List, class ..._Preds>
struct __lazy_or_impl;

template <class ..._Preds>
struct __lazy_or_impl<true, _Preds...> : true_type {};

template <>
struct __lazy_or_impl<false> : false_type {};

template <class _Hp, class ..._Tp>
struct __lazy_or_impl<false, _Hp, _Tp...>
        : __lazy_or_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class ..._Pr>
struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};



template <class _Pred>
struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};


template<class...> struct __and_;
template<> struct __and_<> : true_type {};

template<class _B0> struct __and_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __and_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};


template<class...> struct __or_;
template<> struct __or_<> : false_type {};

template<class _B0> struct __or_<_B0> : _B0 {};

template<class _B0, class _B1>
struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};

template<class _B0, class _B1, class _B2, class... _Bn>
struct __or_<_B0, _B1, _B2, _Bn...>
        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};


template<class _Tp>
struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};





template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_const<_Tp const> : public true_type {};
# 612 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};
# 622 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
# 659 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 677 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};


template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
# 710 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
# 725 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};
# 739 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
# 752 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_rvalue_reference : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};


template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference<_Tp&&> : public true_type {};
# 780 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 800 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 823 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};
# 833 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
namespace __libcpp_is_function_imp
{
struct __dummy_type {};
template <class _Tp> char __test(_Tp*);
template <class _Tp> char __test(__dummy_type);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source(int);
template <class _Tp> __dummy_type __source(...);
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};
# 867 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};


template <class _Tp> struct __libcpp_is_member_function_pointer
    : public false_type {};

template <class _Ret, class _Class>
struct __libcpp_is_member_function_pointer<_Ret _Class::*>
    : public is_function<_Ret> {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};
# 890 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
# 903 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};
# 916 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 942 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
# 953 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};
# 965 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__visibility__("default"))) is_scalar<nullptr_t> : public true_type {};
# 981 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};
# 994 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
# 1005 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};







template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};







template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};
# 1072 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};







template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};
# 1098 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);

template <class _Tp>
decltype(std::__1::__declval<_Tp>(0))
declval() noexcept;
# 1115 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};



template <class _Tp, class _Up>
struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};

struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};







template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                is_same<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool,(_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};
# 1187 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool,(_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};
# 1207 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 1221 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
# 1239 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};







template <class _Tp>
struct __attribute__ ((__visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};







namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};
# 1311 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
# 1332 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__ ((__visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1378 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
namespace __is_convertible_imp
{
template <class _Tp> void __test_convert(_Tp);

template <class _From, class _To, class = void>
struct __is_convertible_test : public false_type {};

template <class _From, class _To>
struct __is_convertible_test<_From, _To,
    decltype(std::__1::__is_convertible_imp::__test_convert<_To>(std::__1::declval<_From>()))> : public true_type
{};

template <class _Tp, bool _IsArray = is_array<_Tp>::value,
                     bool _IsFunction = is_function<_Tp>::value,
                     bool _IsVoid = is_void<_Tp>::value>
                     struct __is_array_function_or_void {enum {value = 0};};
template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
}

template <class _Tp,
    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
struct __is_convertible_check
{
    static const size_t __v = 0;
};

template <class _Tp>
struct __is_convertible_check<_Tp, 0>
{
    static const size_t __v = sizeof(_Tp);
};

template <class _T1, class _T2,
    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
struct __is_convertible
    : public integral_constant<bool,
        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value
# 1426 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
    >
{};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};

template <class _T1, class _T2> struct __attribute__ ((__visibility__("default"))) is_convertible
    : public __is_convertible<_T1, _T2>
{
    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
};
# 1462 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1504 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template<typename _Tp> char &__is_polymorphic_impl(
    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
                       int>::type);
template<typename _Tp> __two &__is_polymorphic_impl(...);

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_polymorphic
    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
# 1523 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1540 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};
# 1550 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    static_assert(!is_void<_Aligner>::value, "");
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};
# 1659 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
# 1684 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof__(_Type0),
                                                       __alignof__(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};







template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};
# 1976 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class ..._Tp>
struct __attribute__ ((__visibility__("default"))) common_type {};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp>
{
    typedef typename decay<_Tp>::type type;
};



template <class _Tp, class _Up, class = void>
struct __common_type2 {};

template <class _Tp, class _Up>
struct __common_type2<_Tp, _Up,
    typename __void_t<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type>
{
    typedef typename decay<decltype(
        true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
    )>::type type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp, _Up>
    : __common_type2<_Tp, _Up> {};



template <class ...Tp> struct __common_types;

template <class, class = void>
struct __common_type_impl {};

template <class _Tp, class _Up, class ..._Vp>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
    typedef typename common_type<
        typename common_type<_Tp, _Up>::type, _Vp...
    >::type type;
};

template <class _Tp, class _Up, class ..._Vp>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp, _Up, _Vp...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};
# 2035 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type

__is_assignable_test(_Tp&&, _Arg&&);




template <class _Arg>
false_type

__is_assignable_test(__any, _Arg&&);




template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            decltype(std::__1::__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};
# 2077 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 2088 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_move_assignable

    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_rvalue_reference<_Tp>::type> {};
# 2110 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};
# 2168 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "Can not forward an rvalue as an lvalue.");
    return static_cast<_Tp&&>(__t);
}
# 2238 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__1::forward<_Tp>(__t);
}
# 2260 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
# 2717 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};



template <class _Callable> class result_of;
# 2898 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
namespace __is_construct
{
struct __nat {};
}
# 2916 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, class ..._Args>
typename __select_2nd<decltype(std::__1::move(_Tp(std::__1::declval<_Args>()...))), true_type>::type
__is_constructible_test(_Tp&&, _Args&& ...);

template <class ..._Args>
false_type
__is_constructible_test(__any, _Args&& ...);

template <bool, class _Tp, class... _Args>
struct __libcpp_is_constructible
    : public common_type
             <
                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))
             >::type
    {};



template <class _Rp, class... _A1, class... _A2>
struct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>
    : public false_type
    {};





template <class _Tp>
struct __libcpp_is_constructible<true, _Tp>
    : public is_scalar<_Tp>
    {};




template <class _Tp>
struct __is_constructible_ref
{
    true_type static __lxx(_Tp);
    false_type static __lxx(...);
};

template <class _Tp, class _A0>
struct __libcpp_is_constructible<true, _Tp, _A0>
    : public common_type
             <
                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))
             >::type
    {};



template <class _Tp, class _A0, class ..._Args>
struct __libcpp_is_constructible<true, _Tp, _A0, _Args...>
    : public false_type
    {};



template <bool, class _Tp, class... _Args>
struct __is_constructible_void_check
    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _Args...>
    {};



template <class _Tp, class... _Args>
struct __is_constructible_void_check<true, _Tp, _Args...>
    : public false_type
    {};

template <class ..._Args> struct __contains_void;

template <> struct __contains_void<> : false_type {};

template <class _A0, class ..._Args>
struct __contains_void<_A0, _Args...>
{
    static const bool value = is_void<_A0>::value ||
                              __contains_void<_Args...>::value;
};



template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_constructible
    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value
                                        || is_abstract<_Tp>::value,
                                           _Tp, _Args...>
    {};




template <class _Ap, size_t _Np>
struct __libcpp_is_constructible<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};



template <class _Ap, size_t _Np, class ..._Args>
struct __libcpp_is_constructible<false, _Ap[_Np], _Args...>
    : public false_type
    {};



template <class _Ap, class ..._Args>
struct __libcpp_is_constructible<false, _Ap[], _Args...>
    : public false_type
    {};
# 3214 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};
# 3226 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3238 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_move_constructible

    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3258 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3386 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};
# 3397 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};
# 3408 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_move_constructible

    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3425 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3466 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3477 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};
# 3495 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};
# 3532 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible< true, false, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
{
};

template <class _Tp>
void __implicit_conversion_to(_Tp) noexcept { }

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_constructible< true, true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>
{
};

template <class _Tp, bool _IsReference, class... _Args>
struct __libcpp_is_nothrow_constructible< false, _IsReference, _Tp, _Args...>
    : public false_type
{
};

template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__visibility__("default"))) is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>
{
};
# 3684 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};
# 3695 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3706 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_move_constructible

    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 3723 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() = std::__1::declval<_Arg>()) >
{
};

template <class _Tp, class _Arg>
struct __attribute__ ((__visibility__("default"))) is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
{
};
# 3794 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
# 3805 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};
# 3823 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3889 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3909 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal_type(_Tp)>




    {};
# 3925 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};
# 3940 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copyable



    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>



    {};
# 3957 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};






template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};





template <class ..._Tp> struct __check_complete;

template <>
struct __check_complete<>
{
};

template <class _Hp, class _T0, class ..._Tp>
struct __check_complete<_Hp, _T0, _Tp...>
    : private __check_complete<_Hp>,
      private __check_complete<_T0, _Tp...>
{
};

template <class _Hp>
struct __check_complete<_Hp, _Hp>
    : private __check_complete<_Hp>
{
};

template <class _Tp>
struct __check_complete<_Tp>
{
    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
};

template <class _Tp>
struct __check_complete<_Tp&>
    : private __check_complete<_Tp>
{
};

template <class _Tp>
struct __check_complete<_Tp&&>
    : private __check_complete<_Tp>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (*)(_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (*)(_Param...)>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (_Param...)>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...)>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class>
struct __check_complete<_Rp _Class::*>
    : private __check_complete<_Class>
{
};


template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 4187 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }





template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
    : private __check_complete<_Fp>
{
    using _Result = decltype(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));

    static const bool value =
        conditional<
            !is_same<_Result, __nat>::value,
            typename conditional<
                is_void<_Ret>::value,
                true_type,
                is_convertible<_Result, _Ret>
            >::type,
            false_type
        >::type::value;
};

template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};



template <class _Fp, class ..._Args>
class __attribute__ ((__visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};
# 4404 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type



swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

               noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}



namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = !is_same<__swap1, __nat>::value
                           && !is_same<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
  && noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
# 4553 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 4576 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
# 4671 "/opt/intel/new-sgxsdk/include/libcxx/type_traits" 3
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};



} }
# 111 "/opt/intel/new-sgxsdk/include/libcxx/limits" 2 3

# 1 "/opt/intel/new-sgxsdk/include/libcxx/__undef_min_max" 1 3
# 113 "/opt/intel/new-sgxsdk/include/libcxx/limits" 2 3
# 122 "/opt/intel/new-sgxsdk/include/libcxx/limits" 3
namespace std { inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;



    static constexpr const bool traps = true;



    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return 1.17549435082228750797e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return 3.40282346638528859812e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return 1.19209289550781250000e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return 1.40129846432481707092e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return double(2.22507385850720138309e-308L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return double(1.79769313486231570815e+308L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return double(2.22044604925031308085e-16L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return double(4.94065645841246544177e-324L);}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 64;
    static constexpr const int digits10 = 18;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-16381);
    static constexpr const int min_exponent10 = (-4931);
    static constexpr const int max_exponent = 16384;
    static constexpr const int max_exponent10 = 4932;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return 3.64519953188247460253e-4951L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 39 "Enclave/Edger8rSyntax/Types.cpp" 2
# 1 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 1
# 301 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
# 1 "/opt/intel/new-sgxsdk/include/tlibc/math.h" 1
# 22 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
# 1 "/opt/intel/new-sgxsdk/include/tlibc/sys/limits.h" 1
# 23 "/opt/intel/new-sgxsdk/include/tlibc/math.h" 2

# 1 "/opt/intel/new-sgxsdk/include/tlibc/float.h" 1
# 25 "/opt/intel/new-sgxsdk/include/tlibc/math.h" 2


# 26 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
typedef __float_t float_t;
typedef __double_t double_t;
# 82 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
extern "C" {

extern char __infinity[];




extern char __nan[];





double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double cos(double);
double sin(double);
double tan(double);

double cosh(double);
double sinh(double);
double tanh(double);

double exp(double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);

double pow(double, double);
double sqrt(double);

double ceil(double);
double fabs(double);
double floor(double);
double fmod(double, double);




double acosh(double);
double asinh(double);
double atanh(double);

double exp2(double);
double expm1(double);
int ilogb(double);
double log1p(double);
double log2(double);
double logb(double);
double scalbn(double, int);
double scalbln(double, long int);

double cbrt(double);
double hypot(double, double);

double erf(double);
double erfc(double);
double lgamma(double);
double tgamma(double);

double nearbyint(double);
double rint(double);
long int lrint(double);
long long int llrint(double);
double round(double);
long int lround(double);
long long int llround(double);
double trunc(double);

double remainder(double, double);
double remquo(double, double, int *);

double copysign(double, double);
double nan(const char *);
double nextafter(double, double);

double fdim(double, double);
double fmax(double, double);
double fmin(double, double);

double fma(double, double, double);





float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float cosf(float);
float sinf(float);
float tanf(float);

float acoshf(float);
float asinhf(float);
float atanhf(float);
float coshf(float);
float sinhf(float);
float tanhf(float);

float expf(float);
float exp2f(float);
float expm1f(float);
float frexpf(float, int *);
int ilogbf(float);
float ldexpf(float, int);
float logf(float);
float log10f(float);
float log1pf(float);
float log2f(float);
float logbf(float);
float modff(float, float *);
float scalbnf(float, int);
float scalblnf(float, long int);

float cbrtf(float);
float fabsf(float);
float hypotf(float, float);
float powf(float, float);
float sqrtf(float);

float erff(float);
float erfcf(float);
float lgammaf(float);
float tgammaf(float);

float ceilf(float);
float floorf(float);
float nearbyintf(float);

float rintf(float);
long int lrintf(float);
long long int llrintf(float);
float roundf(float);
long int lroundf(float);
long long int llroundf(float);
float truncf(float);

float fmodf(float, float);
float remainderf(float, float);
float remquof(float, float, int *);

float copysignf(float, float);
float nanf(const char *);
float nextafterf(float, float);

float fdimf(float, float);
float fmaxf(float, float);
float fminf(float, float);

float fmaf(float, float, float);
# 247 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double cosl(long double);
long double sinl(long double);
long double tanl(long double);

long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double coshl(long double);
long double sinhl(long double);
long double tanhl(long double);

long double expl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double frexpl(long double, int *);
int ilogbl(long double);
long double ldexpl(long double, int);
long double logl(long double);
long double log10l(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long double modfl(long double, long double *);
long double scalbnl(long double, int);
long double scalblnl(long double, long int);

long double cbrtl(long double);
long double fabsl(long double);
long double hypotl(long double, long double);
long double powl(long double, long double);
long double sqrtl(long double);

long double erfl(long double);
long double erfcl(long double);
long double lgammal(long double);
long double tgammal(long double);

long double ceill(long double);
long double floorl(long double);
long double nearbyintl(long double);
long double rintl(long double);
long int lrintl(long double);
long long int llrintl(long double);
long double roundl(long double);
long int lroundl(long double);
long long int llroundl(long double);
long double truncl(long double);

long double fmodl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);

long double copysignl(long double, long double);
long double nanl(const char *);
long double nextafterl(long double, long double);

long double fdiml(long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double fmal(long double, long double, long double);
# 319 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
double nexttoward(double, long double);
float nexttowardf(float, long double);

long double nexttowardl(long double, long double);




int __fpclassify(double);
int __fpclassifyf(float);
int __isfinite(double);
int __isfinitef(float);
int __isinf(double);
int __isinff(float);
int __isnan(double);
int __isnanf(float);
int __isnormal(double);
int __isnormalf(float);
int __signbit(double);
int __signbitf(float);

int __fpclassifyl(long double);
int __isfinitel(long double);
int __isinfl(long double);
int __isnanl(long double);
int __isnormall(long double);
int __signbitl(long double);




double drem(double, double);
double exp10(double);
double gamma(double);
double gamma_r(double, int *);
double j0(double);
double j1(double);
double jn(int, double);
double lgamma_r(double, int *);
double pow10(double);
double scalb(double, double);

double significand(double);
void sincos(double, double *, double *);
double y0(double);
double y1(double);
double yn(int, double);


int finite(double);

float dremf(float, float);
float exp10f(float);
float gammaf(float);
float gammaf_r(float, int *);
float j0f(float);
float j1f(float);
float jnf(int, float);
float lgammaf_r(float, int *);
float pow10f(float);
float scalbf(float, float);
int signbitf(float);
float significandf(float);
void sincosf(float, float *, float *);
float y0f(float);
float y1f(float);
float ynf(int, float);
int finitef(float);
int isinff(float);
int isnanf(float);

long double dreml(long double, long double);
long double exp10l(long double);
long double gammal(long double);
long double gammal_r(long double, int *);
long double j0l(long double);
long double j1l(long double);
long double jnl(int, long double);
long double lgammal_r(long double, int *);
long double pow10l(long double);
long double scalbl(long double, long double);
int signbitl(long double);
long double significandl(long double);
void sincosl(long double, long double *, long double *);
long double y1l(long double);
long double y0l(long double);
long double ynl(int, long double);
int finitel(long double);
int isinfl(long double);
int isnanl(long double);
# 422 "/opt/intel/new-sgxsdk/include/tlibc/math.h"
typedef float _Decimal32 __attribute__((mode(SD)));
typedef float _Decimal64 __attribute__((mode(DD)));
typedef float _Decimal128 __attribute__((mode(TD)));



}
# 302 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 2







       
# 310 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3







# 316 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __lcpp_x) noexcept
{
    return 
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __signbitf(
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __signbit(
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __signbitl(
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 321 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                           ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept
{
    return 
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __fpclassifyf(
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __fpclassify(
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __fpclassifyl(
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 345 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                              ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept
{
    return 
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __isfinitef(
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __isfinite(
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __isfinitel(
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 369 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                            ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __lcpp_x) noexcept
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __lcpp_x) noexcept
{
    return 
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __isinff(
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __isinf(
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __isinfl(
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 393 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                         ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __lcpp_x) noexcept
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __lcpp_x) noexcept
{
    return 
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __isnanf(
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __isnan(
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __isnanl(
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 417 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                         ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept
{
    return 
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ((sizeof (
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (float)) ? __isnormalf(
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : (sizeof (
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) == sizeof (double)) ? __isnormal(
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) : __isnormall(
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 441 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                            ;
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (!(isnan((
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )) || isnan((
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))) && (
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) > (
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 465 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                       ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (!(isnan((
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )) || isnan((
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))) && (
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) >= (
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 495 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                            ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (!(isnan((
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )) || isnan((
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))) && (
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) < (
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 525 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                    ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (!(isnan((
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )) || isnan((
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))) && (
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) <= (
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 555 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                         ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (!(isnan((
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )) || isnan((
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))) && ((
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) > (
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) || (
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) > (
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          )))
# 585 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                           ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return 
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          (isnan(
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_x
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ) || isnan(
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
          __lcpp_y
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath"
          ))
# 615 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
                                         ;
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}



namespace std { inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;
# 662 "/opt/intel/new-sgxsdk/include/libcxx/cmath" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __lcpp_x) noexcept {return fabsf(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __lcpp_x) noexcept {return fabs(__lcpp_x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __lcpp_x) noexcept {return fabsl(__lcpp_x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __lcpp_x) noexcept {return acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __lcpp_x) noexcept {return acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return acos((double)__lcpp_x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __lcpp_x) noexcept {return asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __lcpp_x) noexcept {return asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return asin((double)__lcpp_x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __lcpp_x) noexcept {return atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __lcpp_x) noexcept {return atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return atan((double)__lcpp_x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __lcpp_x) noexcept {return ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __lcpp_x) noexcept {return ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ceil((double)__lcpp_x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __lcpp_x) noexcept {return cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __lcpp_x) noexcept {return cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return cos((double)__lcpp_x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __lcpp_x) noexcept {return coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __lcpp_x) noexcept {return coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return cosh((double)__lcpp_x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __lcpp_x) noexcept {return expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __lcpp_x) noexcept {return expl(__lcpp_x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return exp((double)__lcpp_x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __lcpp_x) noexcept {return fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __lcpp_x) noexcept {return fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return fabs((double)__lcpp_x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __lcpp_x) noexcept {return floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __lcpp_x) noexcept {return floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return floor((double)__lcpp_x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return frexp((double)__lcpp_x, __lcpp_e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ldexp((double)__lcpp_x, __lcpp_e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __lcpp_x) noexcept {return logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __lcpp_x) noexcept {return logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return log((double)__lcpp_x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __lcpp_x) noexcept {return log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __lcpp_x) noexcept {return log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return log10((double)__lcpp_x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return modfl(__lcpp_x, __lcpp_y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __lcpp_x) noexcept {return sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __lcpp_x) noexcept {return sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return sin((double)__lcpp_x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __lcpp_x) noexcept {return sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __lcpp_x) noexcept {return sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return sinh((double)__lcpp_x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __lcpp_x) noexcept {return sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __lcpp_x) noexcept {return sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return sqrt((double)__lcpp_x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __lcpp_x) noexcept {return tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __lcpp_x) noexcept {return tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return tan((double)__lcpp_x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __lcpp_x) noexcept {return tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __lcpp_x) noexcept {return tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return tanh((double)__lcpp_x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __lcpp_x) noexcept {return acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __lcpp_x) noexcept {return acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return acosh((double)__lcpp_x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __lcpp_x) noexcept {return asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __lcpp_x) noexcept {return asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return asinh((double)__lcpp_x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __lcpp_x) noexcept {return atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __lcpp_x) noexcept {return atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return atanh((double)__lcpp_x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __lcpp_x) noexcept {return cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __lcpp_x) noexcept {return cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return cbrt((double)__lcpp_x);}




using ::copysign;
using ::copysignf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __lcpp_x,
                                                float __lcpp_y) noexcept {
  return copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return copysignl(__lcpp_x, __lcpp_y);
}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __lcpp_x) noexcept {return erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __lcpp_x) noexcept {return erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return erf((double)__lcpp_x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __lcpp_x) noexcept {return erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __lcpp_x) noexcept {return erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return erfc((double)__lcpp_x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __lcpp_x) noexcept {return exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __lcpp_x) noexcept {return exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return exp2((double)__lcpp_x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __lcpp_x) noexcept {return expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __lcpp_x) noexcept {return expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return expm1((double)__lcpp_x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::fmaf;
using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value &&
                      is_same<_A3, __result_type>::value)), "");
    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __lcpp_x) noexcept {return ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __lcpp_x) noexcept {return ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ilogb((double)__lcpp_x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __lcpp_x) noexcept {return lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __lcpp_x) noexcept {return lgammal(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return lgamma((double)__lcpp_x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __lcpp_x) noexcept {return llrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __lcpp_x) noexcept {return llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {return llrint((double)__lcpp_x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __lcpp_x) noexcept {return llroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __lcpp_x) noexcept {return llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {return llround((double)__lcpp_x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __lcpp_x) noexcept {return log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __lcpp_x) noexcept {return log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return log1p((double)__lcpp_x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __lcpp_x) noexcept {return log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __lcpp_x) noexcept {return log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return log2((double)__lcpp_x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __lcpp_x) noexcept {return logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __lcpp_x) noexcept {return logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return logb((double)__lcpp_x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __lcpp_x) noexcept {return lrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __lcpp_x) noexcept {return lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {return lrint((double)__lcpp_x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __lcpp_x) noexcept {return lroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __lcpp_x) noexcept {return lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {return lround((double)__lcpp_x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __lcpp_x) noexcept {return nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __lcpp_x) noexcept {return nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return nearbyint((double)__lcpp_x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return nexttoward((double)__lcpp_x, __lcpp_y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __lazy_enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    __promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __lcpp_x) noexcept {return rintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __lcpp_x) noexcept {return rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {return rint((double)__lcpp_x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __lcpp_x) noexcept {return roundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __lcpp_x) noexcept {return roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {return round((double)__lcpp_x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return scalbln((double)__lcpp_x, __lcpp_y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return scalbn((double)__lcpp_x, __lcpp_y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __lcpp_x) noexcept {return tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __lcpp_x) noexcept {return tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return tgamma((double)__lcpp_x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __lcpp_x) noexcept {return truncf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __lcpp_x) noexcept {return truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {return trunc((double)__lcpp_x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 40 "Enclave/Edger8rSyntax/Types.cpp" 2








# 47 "Enclave/Edger8rSyntax/Types.cpp"
bool almost_equal(double x, double y)
{


    return std::abs(x-y) <= std::numeric_limits<double>::epsilon() * std::abs(x+y) * 2;
}


bool almost_equal(float x, float y)
{


    return std::abs(x-y) <= std::numeric_limits<float>::epsilon() * std::abs(x+y) * 2;
}




void ecall_type_char(char val)
{
    
# 67 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 67 "Enclave/Edger8rSyntax/Types.cpp"
   val == 0x12
# 67 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 67, __func__, 
# 67 "Enclave/Edger8rSyntax/Types.cpp"
   "val == 0x12"
# 67 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 67 "Enclave/Edger8rSyntax/Types.cpp"
                      ;

    (void)(val);

}




void ecall_type_int(int val)
{
    
# 78 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 78 "Enclave/Edger8rSyntax/Types.cpp"
   val == 1234
# 78 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 78, __func__, 
# 78 "Enclave/Edger8rSyntax/Types.cpp"
   "val == 1234"
# 78 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 78 "Enclave/Edger8rSyntax/Types.cpp"
                      ;

    (void)(val);

}




void ecall_type_float(float val)
{
    
# 89 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 89 "Enclave/Edger8rSyntax/Types.cpp"
   almost_equal(val, (float)1234.0)
# 89 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 89, __func__, 
# 89 "Enclave/Edger8rSyntax/Types.cpp"
   "almost_equal(val, (float)1234.0)"
# 89 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 89 "Enclave/Edger8rSyntax/Types.cpp"
                                           ;

    (void)(val);

}




void ecall_type_double(double val)
{
    
# 100 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 100 "Enclave/Edger8rSyntax/Types.cpp"
   almost_equal(val, (double)1234.5678)
# 100 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 100, __func__, 
# 100 "Enclave/Edger8rSyntax/Types.cpp"
   "almost_equal(val, (double)1234.5678)"
# 100 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 100 "Enclave/Edger8rSyntax/Types.cpp"
                                               ;

    (void)(val);

}




void ecall_type_size_t(size_t val)
{
    
# 111 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 111 "Enclave/Edger8rSyntax/Types.cpp"
   val == (size_t)12345678
# 111 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 111, __func__, 
# 111 "Enclave/Edger8rSyntax/Types.cpp"
   "val == (size_t)12345678"
# 111 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 111 "Enclave/Edger8rSyntax/Types.cpp"
                                  ;

    (void)(val);

}




void ecall_type_wchar_t(wchar_t val)
{
    
# 122 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 122 "Enclave/Edger8rSyntax/Types.cpp"
   val == (wchar_t)0x1234
# 122 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 122, __func__, 
# 122 "Enclave/Edger8rSyntax/Types.cpp"
   "val == (wchar_t)0x1234"
# 122 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 122 "Enclave/Edger8rSyntax/Types.cpp"
                                 ;

    (void)(val);

}




void ecall_type_struct(struct struct_foo_t val)
{
    
# 133 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 133 "Enclave/Edger8rSyntax/Types.cpp"
   val.struct_foo_0 == 1234
# 133 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 133, __func__, 
# 133 "Enclave/Edger8rSyntax/Types.cpp"
   "val.struct_foo_0 == 1234"
# 133 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 133 "Enclave/Edger8rSyntax/Types.cpp"
                                   ;
    
# 134 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 134 "Enclave/Edger8rSyntax/Types.cpp"
   val.struct_foo_1 == 5678
# 134 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 134, __func__, 
# 134 "Enclave/Edger8rSyntax/Types.cpp"
   "val.struct_foo_1 == 5678"
# 134 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 134 "Enclave/Edger8rSyntax/Types.cpp"
                                   ;

    (void)(val);

}






void ecall_type_enum_union(enum enum_foo_t val1, union union_foo_t *val2)
{
    if (sgx_is_outside_enclave(val2, sizeof(union union_foo_t)) != 1)
        abort();
    val2->union_foo_0 = 1;
    val2->union_foo_1 = 2;
    
# 151 "Enclave/Edger8rSyntax/Types.cpp" 3
   ((
# 151 "Enclave/Edger8rSyntax/Types.cpp"
   val1 == ENUM_FOO_0
# 151 "Enclave/Edger8rSyntax/Types.cpp" 3
   ) ? (void)0 : __assert("Enclave/Edger8rSyntax/Types.cpp", 151, __func__, 
# 151 "Enclave/Edger8rSyntax/Types.cpp"
   "val1 == ENUM_FOO_0"
# 151 "Enclave/Edger8rSyntax/Types.cpp" 3
   ))
# 151 "Enclave/Edger8rSyntax/Types.cpp"
                             ;

    (void)(val1);

}
